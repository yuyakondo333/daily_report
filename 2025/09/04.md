# 今日学んだこと
## 取り組んだ課題
- TypeScriptクイズ
- paiza
## わかったこと
### 関数オーバーロードの順序
```typescript
// 間違った例（anyが最初）
declare function fn(x: any): any;           // ← 1番目: 必ずここにマッチ
declare function fn(x: HTMLElement): number;       // ← 到達不可能
declare function fn(x: HTMLDivElement): string;    // ← 到達不可能

// 正しい例（具体的なものから順に）
declare function fn(x: HTMLDivElement): string;    // ← 1番目: 具体的
declare function fn(x: HTMLElement): number;       // ← 2番目: 一般的
declare function fn(x: any): any;                  // ← 3番目: フォールバック
```
- 具体的な型から順に配置
- `any`は最後に置く
- 戻り値が同じなら可能な限りオプショナル引数を使う
### オーバーロードとオプショナル引数
```typescript
// 冗長
interface Example {
  diff(one: string): number;
  diff(one: string, two: string): number;
  diff(one: string, two: string, three: boolean): number;
}

// 推奨
interface Example {
  diff(one: string, two?: string, three?: boolean): number;
}
```
- 戻り値の型が同じ場合はより簡潔
- 実装が単純化される
- 型安全性が保持される
### 関数の引数互換性
- 代入先が要求する引数 ≤ 代入元が受け取れる引数 ならOK
```typescript
let x = (a: number) => 0;                    // 1個の引数
let y = (b: number, s: string) => 0;         // 2個の引数

y = x;  // OK: xは1個の引数を受け取り、yは2個渡されても問題なし
x = y;  // エラー: yは2個の引数が必要だが、xは1個しか渡されない
```
### オブジェクトの戻り値互換性
- 代入元の戻り値は代入先が期待するプロパティを全て含む必要がある
```typescript
let x = () => ({ name: "Alice" });
let y = () => ({ name: "Alice", location: "Seattle" });

x = y;  // OK: yは`name`と`location`を返すので、xが期待する`name`は満たされる
y = x;  // エラー: xは`name`のみ返すが、yは`location`も期待する
```
### ジェネリック関数の互換性
- ジェネリック関数同士の代入では、型変数は`any`として判定される。
```typescript
let identity = function<T>(x: T): T { return x; };
let reverse = function<U>(y: U): U { return y; };

identity = reverse;  // ✅ OK: 型変数は実質的に`any`として扱われる
```
### Union型で関数が呼び出せない問題
- 以下はエラーになる
    - objが実際にStrFuncなのかNumFuncなのか、実行時まで分からない
```typescript
type StrFunc = (arg: string) => string;
type NumFunc = (arg: number) => string;

declare const obj: StrFunc | NumFunc;
obj("fa");  // エラーになる！？
```
- 解決方法は2つ
    - 渡される引数に確信がある場合は型アサーションを使う
    - 不確定な場合は型ガードを使う
```typescript
// 1. 型アサーション（確信がある時だけ）
(obj as StrFunc)("fa");
(obj as NumFunc)(2);

// 2. 型ガード（安全）
if (isStrFunc(obj)) {
  obj("fa");  // ここではobjはStrFunc確定
} else {
  obj(2);     // ここではobjはNumFunc確定
}
```
## 感じたこと
- オーバーロードするときは具体的な型から書く
- 同じ戻り値ならオプショナル引数を使う
- 型アサーションは本当に確信がある時だけ
## 次やること
- TypeScript問題集
- paiza
- React with TypeScript
## 学習時間
- Today: 5h
- Total: 1669h