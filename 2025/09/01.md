# 今日学んだこと
## 取り組んだ課題
- PokeAPiを使った無限スクロールアプリ
## わかったこと
### Cache-Controlヘッダー
```javascript
'Cache-Control': 'public, max-age=3600, stale-while-revalidate=86400'
// 0-60分   : キャッシュから即座に返答（サーバーアクセスなし）
// 1-24時間 : 古いキャッシュを返しつつ、バックグラウンドで更新
// 24時間超 : 必ずサーバーから新規取得
```
- `public`: 誰でもキャッシュ可能（ブラウザ、CDN、プロキシ）
- `max-age=3600`: 1時間は「新鮮」なデータとして扱う
- `stale-while-revalidate=86400`: 24時間は古いデータでも使用可、裏で更新
### useSWRInfiniteの内部動作
- データフロー
```
setSize実行 → useSWRInfinite内部処理 → getKey実行 → fetcher実行 → route.js実行
```
### getKey関数の引数管理
```javascript
const getKey = (pageIndex, previousPageData) => {
  // pageIndexとpreviousPageDataはuseSWRInfiniteが管理
};
```
- 引数の更新タイミング
    - トリガー: `setSize()`実行時
    - 更新場所: `useSWRInfinite`内部のuseEffect
    - 更新方法: `size`の数だけループして毎回新しく作成
### スクロール制御とパフォーマンス
- isValidatingの重要性
```javascript
if (!isValidating && hasMore) {
  setSize(prev => prev + 1);
}
```
- `isValidating`あり
    - 1回ずつ適切にデータ取得
    - 無駄なAPIリクエストを防止
    - ユーザーへの読み込み状況表示
-  `isValidating`なし
    - 高速スクロール時に複数の`setSize`が同時実行
    - 結果: 大量の無駄なAPIリクエストが起こり、フロント側でユーザー体験が下がる
## 感じたこと
- `useSWRInfinite`が内部で実行していることが`useState`であることがわかってホッとした
- 各レベルにおけるエラーハンドリングが違うこと
    - APIレベル
    - データ処理レベル
    - UIレベル
## 次やること
- TypeScript問題集
## 学習時間
- Today: 4.5h
- Total: 1655h