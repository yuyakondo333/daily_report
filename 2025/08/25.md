# 今日学んだこと
## 取り組んだこと
- Poke APIで無限スクロールアプリ作成
## わかったこと
### URLパラメータの処理
```javascript
const { searchParams } = new URL(request.url);
const offset = parseInt(searchParams.get('offset')) || 0;
const limit = parseInt(searchParams.get('limit')) || 9;
```
- searchParams.get()は文字列を返すためparseInt()が必要
- || 0でデフォルト値設定
- offset/limitパラメータでページネーション実現
### 配列生成の可読性重視
```javascript
// 関数型（短いが理解しにくい）
const numbers = Array.from({ length: limit }, (_, i) => offset + i + 1);

// for loop（可読性重視、チーム開発向け）
const numbers = [];
for (let i = 0; i < actualLimit; i++) {
  const pokemonId = offset + i + 1;
  numbers.push(pokemonId);
}
```
- パフォーマンスが同程度なら可読性を優先
### パフォーマンス最適化の判断
- 日本語名・タイプ名変換（32回のAPI呼び出し、3秒）
- 英語名使用（9回のAPI呼び出し、0.5-1秒）
- 判断基準: 実用性を重視
### fetch APIの正しい理解
```javascript
// 間違い
if (!response) { /* 404でも実行されない */ }

// 正しい
if (!response.ok) { /* HTTPエラーで正しく実行される */ }
```
- fetchはネットワークエラー以外では例外を投げない
### useEffect と依存配列の落とし穴
```javascript
// 問題のあるパターン
useEffect(() => {
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []); // 空配列だが、handleScrollは外部状態に依存
```
- 依存配列とイベントリスナーの組み合わせは複雑
- `useEffect`の第二引数に空の配列を指定した場合
    
    初回レンダリング時のみ実行される
    
- window.innerHeightについて
    - 画面の縦幅
    - https://developer.mozilla.org/ja/docs/Web/API/Window/innerHeight
- window.scrollYについて
    - ページの **垂直方向（上から下）** のスクロール量
    - https://developer.mozilla.org/ja/docs/Web/API/Window/scrollY
- **スクロールイベントの監視**
    - `window.addEventListener('scroll', handleScroll);`
## 感じたこと
- スクロールイベントリスナーのstale closure解決が出来なかった
## 次やること
- リファクタリング
## 学習時間
- Today: 6h
- Total: 1627h