# 今日学んだこと
## 取り組んだ課題
- Next.js公式チュートリアル
## わかったこと
### ルートの仕組み

- app配下のディレクトリに`page.js, route.js` がないと<br>
Routableとならない

- 以下のディレクトリ構造の場合は以下の3つのルートへRoutableとなる

    - app: /
    - dashboard: /dashboard
    - dashboard/settings: /dashboard/settings

```tsx
app/
|-- page.tsx
|-- dashboard/
|   |-- page.tsx
|   |-- settings/
|       |-- page.tsx
```

- ディレクトリの始まりが「 _ 」から始まる場合<br>
その配下の`page.js, route.js`はルーティングから除外される

- （）をディレクトリ名に入れることで<br>
管理者ページと一般ユーザーページを分けることができる

```tsx
app/
|-- (admin)
	|-- dashboard/
	  |-- page.tsx

|-- (general)
	|-- about/
	  |-- page.tsx
	|-- blog/
	  |-- page.tsx
```

- 「[]」とディレクトリ名とすることで<br>
動的なルートセグメントが作成される（ブログ投稿、製品ページなど）

- ページ内のリンクは`Link` コンポーネントを使用する<br>
`href`にプロパティを渡す

```tsx
import Link from 'next/link'
 
export default async function Post({ post }) {
  const posts = await getPosts()
 
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.slug}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

- `Link`コンポーネントは自動的にプリフェッチしてくれる

- プリフェッチ：ユーザーがルートに移動する前に、バックグラウンドでルートを読み込むプロセス

- **静的ルート**
    - 完全なルートがプリフェッチされる
    
- **動的ルート**[`loading.tsx`](https://nextjs.org/docs/app/api-reference/file-conventions/loading)
    
    - プリフェッチはスキップされる<br>
    または、存在する場合はルートが部分的にプリフェッチされる
    

- ストリーミングを使用することによって<br>
準備が整い次第、その一部だけをクライアントに送信できる

- ストリーミングを使用するには、`loading.tsx`ルート フォルダーに を作成

- プリフェッチを無効にすることもできる<br>
無限スクロール等の膨大なリンクリストの場合は無効にする方が最適

```tsx
<Link prefetch={false} href="/blog">
  Blog
</Link>
```

- 完全に無効化すると以下のトレードオフとなる

    - 静的ルートはユーザーがリンクをクリックしたときにのみ取得されます。
    - クライアントが動的ルートに移動する前に、<br>まずサーバー上で動的ルートをレンダリングする必要がある**。**

- プリフェッチを完全に無効にすることなくリソース使用量を削減するには<br>
ホバー時のみプリフェッチを行うこと

```tsx
'use client'
 
import Link from 'next/link'
import { useState } from 'react'
 
function HoverPrefetchLink({
  href,
  children,
}: {
  href: string
  children: React.ReactNode
}) {
  const [active, setActive] = useState(false)
 
  return (
    <Link
      href={href}
      prefetch={active ? null : false}
      onMouseEnter={() => setActive(true)}
    >
      {children}
    </Link>
  )
}
```

### クライアントコンポーネントを使う場面

- state, イベントハンドラー
`useState, onClick, onChange`
- `useEffect`
- ブラウザ専用のAPI
`window, localStorage, Navigator.geolocation`
- カスタムフック

### サーバーサイドコンポーネントを使う場面

- DBやAPIからデータ取得
- API キー、トークン、その他の機密情報をクライアントに公開せず使用する場合
- ブラウザに送信される JavaScript の量を減らす
- [First Contentful Paint（FCP）の](https://web.dev/fcp/)改善コンテンツを段階的にクライアントにストリーミングします。

### RSC ペイロード

- レンダリングされた React Server Componentsツリーのコンパクトなバイナリ表現
- クライアント側のReactがブラウザのDOMを更新するために使用
- RSCペイロードには以下が含まれる

    - サーバーコンポーネントのレンダリング結果
    - クライアントコンポーネントをレンダリングする場所の<br>プレースホルダーとその JavaScript ファイルへの参照
    - サーバーコンポーネントからクライアントコンポーネントに渡されるすべてのプロパティ

**"use client”**が先頭に書かれると

- そのファイルのすべてのインポートと子コンポーネントは
クライアントバンドル の一部とみなされる

### Suspense

- 条件が満たされるまで、アプリケーションの一部のレンダリングを延期するために使用

- 部分的な事前レンダリングではサスペンスは<br>コンポーネントツリー内の動的な境界をマークするために使用

- ビルド時に、Next.js は静的コンテンツと`fallback`UI を事前レンダリングする

### 部分的事前レンダリング（PPR) を有効にする場合

- `next.config.ts` で ppr オプションを追加
- 任意のファイルで以下を追記
`export const experimental_ppr = true`
- `experimental_ppr` はルートセグメントのすべての子要素に適応される
ルートの最上位セグメントのみに追加すれば十分
- 子セグメントの PPR を無効にするには子セグメントで以下を追記
`export const experimental_ppr = false`

### サーバーコンポーネントでデータを取得するには

- fetch API を使用
- ORM 又は DB を使用

### クライアントコンポーネントでデータを取得するには

- use hook を使用
https://react.dev/reference/react/use
- SWR のようなライブラリや React クエリを使用

### リクエストの重複を排除し、データをキャッシュ

オプトアウトとは↓<br>

https://www.ricoh.co.jp/magazines/direct-marketing/column/g00056/

**Request Memoization**

- 同じURLとオプションで呼び出されたリクエストを自動的にメモ化する機能
- 同一データを複数箇所で利用する際に
ネットワークリクエストの重複を防ぎ、パフォーマンスを最適化
- 初回リクエストで出たーを外部ソースから取得して結果をメモリに保存（キャッシュMISS）
    - 2回目以降の同じリクエストは、メモリから結果を取得しネットワークリクエストをスキップする（キャッシュHIT）
- `fetch` のGETリクエスト限定
- Reactコンポーネントツリー内限定

### アプリケーションでストリーミングを実装する方法

- `page.js` と`loading.js` を同階層にする
    - ページ全体がローディング
- `Suspense` でコンポーネントをラップする
    - 一部だけローディング、他は即座に表示

- `Promise.all` で並列処理で非同期処理の時間を短縮できる

### データのプリロード

- 実際のAPIを呼び出し実行
- 結果をRequest Memoizationのキャッシュに保存
- 後で同じ関数が呼ばれた場合、キャッシュから即座に返す
## 感じたこと
- 初知識が多すぎる
- コードを見ているだけだから、少しずつ手を動かす
## 次やること
- 公式チュートリアル データの更新
## 学習時間
- Today: 7.5h
- Total: 1562h