# 今日学んだこと
## 取り組んだ課題
- TypeScript練習問題集
## わかったこと
### Type Widening（型の拡張）
```typescript
const user = { name: "kenji", age: 98 };
// 型: { name: string, age: number }
```
- オブジェクトは可変なので、後で値を変更できるようにリテラル型からプリミティブ型に拡張される
- `as const` を使用して定数にする
### Conditional Types（条件分岐型）
- `T extends U ? X : Y` の意味
    - TがUに代入可能ならX、そうでなければY
        
        ```tsx
        // ユースケース: 関数の引数として渡せるかチェック
        type CanAssign<T, U> = T extends U ? "assignable" : "not assignable";
        
        function acceptString(s: string) {}
        type Test1 = CanAssign<"hello", string>; // "assignable"
        type Test2 = CanAssign<number, string>;  // "not assignable"
        
        // 実用例: 安全な変換関数
        type SafeConvert<T, U> = T extends U ? T : never;
        declare function convert<T, U>(value: T): SafeConvert<T, U>;
        ```
        
    - TがUの部分型（subtype）ならX、そうでなければY
        
        ```tsx
        // ユースケース: 型階層の判定
        type IsSubtype<T, U> = T extends U ? true : false;
        
        // 型階層例
        type Test1 = IsSubtype<"hello", string>;     // true (リテラル < プリミティブ)
        type Test2 = IsSubtype<string, unknown>;     // true (具象 < 抽象)
        type Test3 = IsSubtype<never, any>;          // true (bottom type)
        
        // 実用例: より具体的な型を要求
        type RequireMoreSpecific<T, U> = T extends U 
          ? U extends T 
            ? never  // 同じ型は拒否
            : T      // より具体的な型のみ許可
          : never;
        ```
        
    - TとUに互換性があればX、そうでなければY
        
        ```tsx
        // ユースケース: 構造的互換性チェック
        type Compatible<T, U> = T extends U ? "compatible" : "incompatible";
        
        interface Base { name: string; }
        interface Extended { name: string; age: number; }
        
        type Test1 = Compatible<Extended, Base>;     // "compatible"
        type Test2 = Compatible<Base, Extended>;     // "incompatible"
        
        // 実用例: APIレスポンス互換性チェック
        type ApiCompatible<Response, Expected> = Response extends Expected
          ? Response
          : { error: "Response shape incompatible with expected format" };
        ```
### keyof演算子とMapped Types
```typescript
type FunctionPropertyNames<T> = {
  [K in keyof T]: T[K] extends Function ? K : never
}[keyof T]
```
- `keyof T`でプロパティ名を取得
- Mapped Typeで各プロパティを変換
- `[keyof T]`でUnion型として抽出
- `never`は自動で除去される
###  infer（型のキャプチャ）
```typescript
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
```
- `infer R`: この位置の型をRという名前でキャプチャする
### 非同期型の扱い
```typescript
type ResolvedType<T> = T extends Promise<infer R> ? R : T;
```
## 感じたこと
- 1つの問題でわからないことが大量に出てくるため<br>理解するのに時間がかかる
## 次やること
- TypeScript練習問題集
## 学習時間
- Today: 4.5h
- Total: 1641h